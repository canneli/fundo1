<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Felipe Canneli - Sophisticated Surreal Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #ff4500;
        }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* Efeito de Bloom Sofisticado */
        .glow-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 30%, rgba(255, 69, 0, 0.2) 100%);
            mix-blend-mode: soft-light;
            z-index: 2;
        }

        /* Camada de Satura√ß√£o Y2K */
        .hyper-juice {
            position: fixed;
            inset: 0;
            pointer-events: none;
            backdrop-filter: saturate(2.2) contrast(1.2) brightness(1.1);
            z-index: 5;
        }

        .studio-vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.3) 100%);
            z-index: 6;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>
    <div class="glow-overlay"></div>
    <div class="hyper-juice"></div>
    <div class="studio-vignette"></div>

    <script>
        let scene, camera, renderer, clock;
        const liquidSurfaces = [];
        const backgroundProps = [];
        let particles;
        let originalVertices = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xff4500);
            scene.fog = new THREE.FogExp2(0xff4500, 0.01);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 65);

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('bg-canvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; 

            clock = new THREE.Clock();

            // ILUMINA√á√ÉO DE EST√öDIO FOTOGR√ÅFICO
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 1.3);
            keyLight.position.set(10, 50, 20);
            scene.add(keyLight);

            const rimLight = new THREE.PointLight(0x39ff14, 20, 120);
            rimLight.position.set(-40, 25, 10);
            scene.add(rimLight);

            const fillLight = new THREE.PointLight(0xffaa00, 15, 120);
            fillLight.position.set(40, 10, 20);
            scene.add(fillLight);

            createLiquidPlanes();
            createHeroEntities();
            createMinimalParticles();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createLiquidPlanes() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Xadrez Nickelodeon: Verde Slime e Laranja
            ctx.fillStyle = '#ff5500'; ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#39ff14'; ctx.fillRect(0, 0, 256, 256); ctx.fillRect(256, 256, 256, 256);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(12, 12);

            const planeGeo = new THREE.PlaneGeometry(400, 400, 60, 60);
            const planeMat = new THREE.MeshStandardMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                roughness: 0.1,
                metalness: 0.3
            });
            
            // Plano Inferior (Ch√£o)
            const floor = new THREE.Mesh(planeGeo, planeMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -20;
            scene.add(floor);
            
            // Plano Superior (Teto)
            const ceiling = new THREE.Mesh(planeGeo, planeMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 50;
            scene.add(ceiling);
            
            // Guardar v√©rtices para anima√ß√£o
            originalVertices = floor.geometry.attributes.position.array.slice();
            
            liquidSurfaces.push(floor, ceiling);
        }

        function createEmojiTexture(char) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = '180px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 20;
            ctx.fillText(char, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createHeroEntities() {
            // Unic√≥rnios (Emoji Look)
            const unicornTex = createEmojiTexture('ü¶Ñ');
            const unicornMat = new THREE.MeshBasicMaterial({ map: unicornTex, transparent: true, side: THREE.DoubleSide });
            
            for(let i=0; i<8; i++) {
                const uni = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), unicornMat);
                uni.position.set(i % 2 === 0 ? -45 : 45, 10 + i*4, -30 - i*15);
                scene.add(uni);
                backgroundProps.push({ mesh: uni, type: 'sprite', floatSpeed: 0.4, posOffset: i });
            }

            // Geometrias Wireframe Y2K
            const wireMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 });
            const starGeo = new THREE.IcosahedronGeometry(7, 0);
            const triGeo = new THREE.ConeGeometry(5, 12, 3);

            for(let i=0; i<12; i++) {
                const shape = new THREE.Mesh(i % 2 === 0 ? starGeo : triGeo, wireMat);
                shape.position.set((Math.random()-0.5)*130, Math.random()*50, -50);
                scene.add(shape);
                backgroundProps.push({ mesh: shape, type: 'geometry', floatSpeed: 0.2, posOffset: Math.random()*5 });
            }
        }

        function createMinimalParticles() {
            const geo = new THREE.SphereGeometry(0.25, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x39ff14, emissive: 0x39ff14, emissiveIntensity: 2 });
            const group = new THREE.Group();
            for(let i=0; i<120; i++) {
                const drop = new THREE.Mesh(geo, mat);
                drop.position.set((Math.random()-0.5)*180, Math.random()*120, (Math.random()-0.5)*120);
                group.add(drop);
            }
            scene.add(group);
            particles = group;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Background Pulsante
            const bgHue = 0.06 + Math.sin(time * 0.15) * 0.03;
            scene.background.setHSL(bgHue, 1, 0.45);
            scene.fog.color.setHSL(bgHue, 1, 0.45);

            // C√¢mera Cinematogr√°fica
            camera.position.x = Math.sin(time * 0.2) * 20;
            camera.position.y = 15 + Math.cos(time * 0.3) * 8;
            camera.lookAt(0, 15, 0);

            // Animar Superf√≠cies L√≠quidas (Ch√£o e Teto)
            liquidSurfaces.forEach((plane, pIdx) => {
                const pos = plane.geometry.attributes.position;
                for(let i=0; i < pos.count; i++) {
                    const x = originalVertices[i*3];
                    const y = originalVertices[i*3 + 1];
                    const phase = pIdx === 0 ? time : -time; 
                    const wave = Math.sin(x * 0.06 + phase * 2) * 2.5 + Math.cos(y * 0.06 + phase * 1.5) * 2.5;
                    pos.array[i*3 + 2] = originalVertices[i*3 + 2] + wave;
                }
                pos.needsUpdate = true;
                plane.material.map.offset.y -= 0.015;
            });

            // Animar Elementos do Cen√°rio
            backgroundProps.forEach(prop => {
                prop.mesh.position.y += Math.sin(time * prop.floatSpeed + prop.posOffset) * 0.06;
                prop.mesh.rotation.z += 0.008;
                prop.mesh.lookAt(camera.position);
            });

            // Chuva de Slime Cristalino
            particles.children.forEach(d => {
                d.position.y -= 0.6;
                if(d.position.y < -40) d.position.y = 80;
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = init;
    </script>
</body>
</html>
